steps:
- pwsh: |
    $config = New-Object System.Collections.ArrayList
    # Tuple format:  (ModuleRepoPath,                           BaseImageName,                   ReturningVstsVar)
    $config.AddRange((
      [Tuple]::Create("edge-agent",                             "azureiotedge-agent-base",       "edgeAgentTag"),
      [Tuple]::Create("edge-hub",                               "azureiotedge-hub-base",         "edgeHubTag"),
      [Tuple]::Create("edge-modules/SimulatedTemperatureSensor","azureiotedge-module-base",      "moduleTag"),
      [Tuple]::Create("test/modules/TestAnalyzer",              "azureiotedge-module-base-full", "fullModuleTag")
      ));

    # Download librocksdb from blob storage
    $artifactLocale = "$(Build.SourcesDirectory)/librocksdb.so"
    Invoke-WebRequest -Uri $("https://edgebuild.blob.core.windows.net/librocksdb/librocksdb.so.$(arch)") -OutFile $artifactLocale

    Write-Output "`n`nBase Image Info"
    foreach ($eachConfig in $config)
    {
      # Fetch tags & version from each module Dockerfiles {../$(arch)/base/Dockerfile, ../$(arch)/Dockerfile}
      # Steps: 
      #  1. Go to a respective Dockerfile as defined in base-image-config.yaml for an underlying base image
      #  2. Read underlying base image tag using "ARG base_tag="
      #  3. Go to a Dockerfile of the module to get tagging that refers to underly base image (2)
      #  4. Set a variable with the tag obtained in (3). This variable has the same name as config by item3 of base-image-config.yaml
      #  5. Output the read values. Format:  <BaseImageName>:<ReferringTag> ðŸ ˜ <UnderLyingBaseImageTag>
      $pathPrefix = "$(Build.SourcesDirectory)/$($eachConfig.Item1)/docker/$(os)/$(arch)"
      $unberlyingFilePath = $pathPrefix + '/base/Dockerfile' | Resolve-path
      $underlyingTag = $($(Get-Content $unberlyingFilePath | Select-String "ARG base_tag=") -split "=")[1]
      $imageFilePath = $pathPrefix + '/Dockerfile' | Resolve-path
      Set-Variable -Name "$($eachConfig.Item3)" -Value "$($($(Get-Content $imageFilePath | Select-String "ARG base_tag=") -split "=")[1])"
      Write-Output "$($eachConfig.Item2):$(Get-Variable -Name "$($eachConfig.Item3)" -ValueOnly) ðŸ ˜ $underlyingTag"

      # Extract version number from the *-linux* base image
      # Uses (ReturningVstsVar) + 'Version' to return the version string as VSTS variable
      #
      # Note:
      #    The output {$(edgeAgentTagVersion), $(edgeHubTagVersion), $(moduleTagVersion), $(fullModuleTagVersion)} are used in base-image-build-and-publish.yaml
      Write-Output "##vso[task.setvariable variable=$($eachConfig.Item3)Version]$($(Get-Variable -Name "$($eachConfig.Item3)" -ValueOnly).split("-")[0])"

      # Copy librocksdb.so to the same directory where base image is going to be built
      $filePath = "$(Build.SourcesDirectory)/$($eachConfig.Item1)/docker/$(os)/$(arch)/base/librocksdb.so"
      Copy-Item $artifactLocale -Destination "$filePath" -ErrorAction Stop
    }

    # Apparently the ##vso[task.setvariable] crop off a string when it sees a newline charater, so chop them off before serialize
    # Note: Serialize -> Pass as DevOpsVar -> Deserialize to get an object
    $serialize_config = $($config | ConvertTo-Json -Compress)
    Write-Output "##vso[task.setvariable variable=serialize_config]$serialize_config"
  displayName: Setup
  name: setup