trigger: none
pr: none

resources:
  repositories:
  - repository: azure-iotedge
    type: github
    endpoint: Azure/azure-iotedge
    name: Azure/azure-iotedge
    ref: refs/pull/101/head # TODO: Remove PR ref once it is merged

variables:
  NugetSecurityAnalysisWarningLevel: warn
  DisableDockerDetector: true
  registry: mcr.microsoft.com

pool:
  name: $(pool.linux.name)
  demands:
  - ImageOverride -equals agent-aziotedge-ubuntu-20.04-docker

steps:
- checkout: azure-iotedge

- script: |
    needs_update=( )

    # transform product-versions.json into a list of images, but group by channel/product so we
    # can figure out which release pipeline to launch for the various images

    images_json=$(cat product-versions.json | jq '
      def images: select(has("type")) | select(.type == "dockerImage") | { name, version };
      def platforms: select(.name == "dockerImage") | .platforms[] | .os as $os | .arch[] | { os: $os, arch: . };
      [
        .channels[] | .name as $channel | .products[] | .id as $product |
        {
          $channel, $product, images: [
            .componentTypes as $types | .components[] | images + ($types[] | platforms) |
              @text "$(registry)/\(.name):\(.version)-\(.os)-\(.arch)"
          ]
        }
      ]
    ')

    images=( $(echo $images_json | jq -r '[ .[].images ] | flatten | join("\n")') )
    for image in ${images[@]}
    do
      echo "image: $image"

      # This command assumes that the $image has a manifest, not a manifest list.
      # In other words, $image is _not_ a multi-arch image.
      read base_image current_digest <<< $(\
        docker buildx imagetools inspect $image --format "{{json .BuildInfo}}" |
        jq -r '@text "\(.sources[0].ref) \(.sources[0].pin)"'
      )

      if [ "$base_image" == 'null' ]
      then
        echo "'$image' does not contain Docker BuildInfo metadata. Skipping..."
        continue
      fi

      latest_digest="sha256:$(docker buildx imagetools inspect --raw $base_image | shasum --algorithm 256 | awk '{print$1}')"

      echo -e "  base:\t\t$base_image\n  current:\t$current_digest\n  latest:\t$latest_digest"

      if [ "$current_digest" != 'null' ] && [ "$current_digest" != "$latest_digest" ]
      then
        echo "  ## NEEDS UPDATE ##"
        needs_update+=( "$image" )
      fi
    done

    # now group the images in $needs_update by channel/product

    needs_update_json=$(printf '%s\n' "${needs_update[@]}" | jq -R '.' | jq -s '.')
    needs_update_json=$(echo "$images_json" | jq --argjson needs_update "$needs_update_json" '
      def find(s): index(s) as $i | if $i != null then .[$i] else null end;
      [
        .[] |
        {
          channel, product, images: [
            .images | find($needs_update[] | .) | select(. != null)
          ]
        } | select(.images | length != 0)
      ]
    ')

    echo "Found ${#needs_update[@]} images that need to be updated:"
    echo "$needs_update_json"
    echo "$needs_update_json" > $(Build.ArtifactStagingDirectory)/updates.json
  displayName: Detect base image updates

- task: PublishBuildArtifacts@1
  displayName: Save list of images to update
  inputs:
    PathtoPublish: $(Build.ArtifactStagingDirectory)/updates.json
    ArtifactName: image-updates
