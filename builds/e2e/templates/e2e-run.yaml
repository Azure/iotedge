parameters:
  containerRegistryPassword: ''
  dpsGroupKeySymmetric: ''
  eventHubCompatibleEndpoint: ''
  iotHubConnectionString: ''
  rootCaPassword: ''
  sas_uri: ''
  test_type: ''

steps:
# This E2E test pipeline uses the following filters in order to skip certain tests:
#   Flaky: Flaky on multiple platforms
#   FlakyOnArm: Flaky only on arm
#   FlakyOnNested: Flaky only on nested
#   SingleNodeOnly: Only applies to single-node cases
#   NestedEdgeOnly: Only applies to nested edge cases
#   NestedEdgeAmqpOnly: Only applies to nested edge cases using amqp upstream protocol
#   LegacyMqttRequired: Only applies to cases with the edgehub legacy mqtt protocol head
#   Amd64Only: Only applies to amd64 architecture
- pwsh: |
    $testFile = '$(binDir)/Microsoft.Azure.Devices.Edge.Test.dll'
    $test_type = '${{ parameters.test_type }}'

    # Filter out flaky tests.
    $filter = 'Category!=Flaky'

    if ('$(minimal)' -eq 'true')
    {
      $filter += '&Name~TempSensor'
    }
    if ('$(arch)' -eq 'arm32v7' -Or '$(arch)' -eq 'arm64v8')
    {
      $filter += '&Category!=FlakyOnArm'
      $filter += '&Category!=Amd64Only'
    }
    if ('$(arch)' -eq 'arm32v7' -And '$(minimal)' -eq 'false')
    {
      # TestUploadModuleLogs and TestUploadSupportBundle use a storage account that is only accessible via private link.
      # If the tests are running from custom on-premises agents (e.g., Raspberry Pis) then they won't have access.
      $filter += '&FullyQualifiedName!~TestUploadModuleLogs&FullyQualifiedName!~TestUploadSupportBundle'
    }
    if ($test_type -eq 'nestededge_mqtt')
    {
      $filter += '&Category!=SingleNodeOnly'
      $filter += '&Category!=NestedEdgeAmqpOnly'
      $filter += '&Category!=LegacyMqttRequired'
      $filter += '&Category!=FlakyOnNested'
      # Below tests were disabled and marked for re-enable when a blocking item was resolved.
      # When it was resolved the tests were never enabled. We need to re-enable these.
      $filter += '&FullyQualifiedName!~Provisioning&FullyQualifiedName!~SasOutOfScope&FullyQualifiedName!~X509ManualProvision&FullyQualifiedName!~AuthorizationPolicyUpdateTest&FullyQualifiedName!~AuthorizationPolicyExplicitPolicyTest'
    }
    elseif ($test_type -eq 'nestededge_amqp')
    {
      $filter += '&Category!=SingleNodeOnly'
      $filter += '&Category!=FlakyOnNested'
      # Below tests were disabled and marked for re-enable when a blocking item was resolved.
      # When it was resolved the tests were never enabled. We need to re-enable these.
      $filter += '&FullyQualifiedName!~Provisioning&FullyQualifiedName!~SasOutOfScope&FullyQualifiedName!~X509ManualProvision&FullyQualifiedName!~AuthorizationPolicyUpdateTest&FullyQualifiedName!~AuthorizationPolicyExplicitPolicyTest'
    }
    elseif ($test_type -eq 'nestededge_isa95')
    {
      $filter = 'Category=nestededge_isa95'
    }
    elseif ($test_type -eq 'http_proxy')
    {
      #Disable tests that don't work in proxy environment. Renable post-investigation.
      $filter += '&FullyQualifiedName!~PlugAndPlay&FullyQualifiedName!~ValidateMetrics'
      #Disable nested edge tests
      $filter += '&Category!=NestedEdgeOnly'
    }
    else
    {
      $filter += '&Category!=NestedEdgeOnly'
    }
    
    sudo --preserve-env dotnet test $testFile --no-build --logger 'trx' --filter "$filter"

  displayName: Run tests ${{ parameters.test_type }}
  env:
    E2E_DPS_GROUP_KEY: ${{ parameters.dpsGroupKeySymmetric }}
    E2E_EVENT_HUB_ENDPOINT: ${{ parameters.eventHubCompatibleEndpoint }}
    E2E_IOT_HUB_CONNECTION_STRING: ${{ parameters.iotHubConnectionString }}
    E2E_REGISTRIES__0__PASSWORD: ${{ parameters.containerRegistryPassword }}
    E2E_ROOT_CA_PASSWORD: ${{ parameters.rootCaPassword }}
    E2E_BLOB_STORE_SAS: ${{ parameters.sas_uri }}
    no_proxy: 'localhost'

- task: PublishTestResults@2
  displayName: Publish test results
  inputs:
    testRunner: vstest
    testResultsFiles: '**/*.trx'
    searchFolder: $(Build.SourcesDirectory)/TestResults
    testRunTitle: End-to-end tests ($(Build.BuildNumber) $(System.JobDisplayName))
    buildPlatform: $(arch)
  # This task takes 15 min when behind a proxy, so disable it
  # see https://github.com/microsoft/azure-pipelines-tasks/issues/11831
  condition: not(variables['Agent.ProxyUrl'])

- pwsh: |
    $test_type = '${{ parameters.test_type }}'
    $logDir = '$(Build.ArtifactStagingDirectory)/logs${{ parameters.test_type }}'
    New-Item $logDir -ItemType Directory -Force | Out-Null
    Out-File "$logDir/$(Build.DefinitionName)-$(Build.BuildNumber)"
    Copy-Item "$(Build.SourcesDirectory)/TestResults" "$logDir/" -Recurse
    # The setup fixtures run outside the scope of any test, so their logs (*-[test|device]-*.log)
    # aren't included in the TRX. Copy them manually here.
    Copy-Item "$(binDir)/*-test-*.log" "$logDir/"
    Copy-Item "$(binDir)/*-device-*.log" "$logDir/"
    Copy-Item "$(binDir)/testoutput.log" "$logDir/"
    Copy-Item "$(binDir)/supportbundle*" "$logDir/"
    $artifactSuffix = '$(Build.BuildNumber)-$(System.JobIdentifier)-$(System.JobAttempt)' -replace '_','-'
    Write-Output "##vso[task.setvariable variable=artifactSuffix]$artifactSuffix"
  displayName: Collect Logs
  condition: always()

- task: PublishBuildArtifacts@1
  displayName: Publish logs
  inputs:
    PathtoPublish: $(Build.ArtifactStagingDirectory)/logs${{ parameters.test_type }}
    ArtifactName: logs-end-to-end-$(artifactSuffix)
  condition: always()
