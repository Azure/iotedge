trigger: none
pr: none

resources:
  pipelines:
  - pipeline: images
    source: 'Azure-IoT-Edge-Core Build Images'
    trigger:
      branches:
      - master
      - release/*
  - pipeline: packages
    source: 'Azure-IoT-Edge-Core Edgelet Packages'
    trigger:
      branches:
      - master
      - release/*

jobs:

# ################################################################################
#   - job: linux_arm32v7
# ################################################################################
#     displayName: Linux arm32v7

#     pool:
#       name: $(pool.name)
#       demands: rpi3-e2e-tests

#     variables:
#       os: linux
#       arch: arm32v7
#       artifactName: iotedged-debian9-arm32v7

#     timeoutInMinutes: 120

#     steps:
#     - template: templates/e2e-clean-directory.yaml
#     - template: templates/e2e-setup.yaml
#     - template: templates/e2e-clear-docker-cached-images.yaml
#     - template: templates/e2e-run.yaml

# ################################################################################
#   - job: linux_amd64
# ################################################################################
#     displayName: Linux amd64

#     pool:
#       vmImage: ubuntu-18.04

#     variables:
#       os: linux
#       arch: amd64
#       artifactName: iotedged-ubuntu18.04-amd64

#     steps:
#     - template: templates/e2e-setup.yaml
#     - template: templates/e2e-run.yaml

################################################################################
  - job: windows_amd64
################################################################################
    displayName: Windows amd64

    pool:
      name: $(pool.name2)
      demands:
        - Agent.OS -equals Windows_NT
        - Agent.OSArchitecture -equals X64
        - ImageOverride -equals aziotedge-winserver-2019-agent
        # - ImageOverride -equals aziotedge-win10-entn2019-agent
        # - run-new-e2e-tests -equals true

    variables:
      os: windows
      arch: amd64
      artifactName: iotedged-windows

    steps:
    # - pwsh: |
    #     $OpenSslPath = Join-Path (Split-Path (get-command git).Source) '..\mingw64\bin' -Resolve
    #     echo "OpenSSL found: $OpenSslPath"
    #     echo "PATH: $env:Path"
    #     # $systemPath = [System.Environment]::GetEnvironmentVariable('Path', [System.EnvironmentVariableTarget]::Machine) -split ';' | Where-Object { $_.Length -gt 0 }
    #     # $systemPath += $OpenSslPath
    #     # [System.Environment]::SetEnvironmentVariable('PATH', ($systemPath -join ';'), [System.EnvironmentVariableTarget]::Machine)

    # - pwsh: |
    #     $ErrorActionPreference = 'Stop'

    #     $scriptBlock = {

    #         function Test-RegistryKey {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (Get-Item -Path $Key -ErrorAction Ignore) {
    #                 $true
    #             }
    #         }

    #         function Test-RegistryValue {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key,

    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Value
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore) {
    #                 $true
    #             }
    #         }

    #         function Test-RegistryValueNotNull {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key,

    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Value
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (($regVal = Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore) -and $regVal.($Value)) {
    #                 $true
    #             }
    #         }

    #         # Added "test-path" to each test that did not leverage a custom function from above since
    #         # an exception is thrown when Get-ItemProperty or Get-ChildItem are passed a nonexistant key path
    #         $tests = @(
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending' }
    #             { Test-RegistryKey -Key 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootInProgress' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' }
    #             { Test-RegistryKey -Key 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\PackagesPending' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\PostRebootReporting' }
    #             { Test-RegistryValueNotNull -Key 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager' -Value 'PendingFileRenameOperations' }
    #             { Test-RegistryValueNotNull -Key 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager' -Value 'PendingFileRenameOperations2' }
    #             { 
    #                 # Added test to check first if key exists, using "ErrorAction ignore" will incorrectly return $true
    #                 'HKLM:\SOFTWARE\Microsoft\Updates' | Where-Object { test-path $_ -PathType Container } | ForEach-Object {            
    #                     (Get-ItemProperty -Path $_ -Name 'UpdateExeVolatile' -ErrorAction Ignore | Select-Object -ExpandProperty UpdateExeVolatile) -ne 0 
    #                 }
    #             }
    #             { Test-RegistryValue -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce' -Value 'DVDRebootSignal' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\ServerManager\CurrentRebootAttemps' }
    #             { Test-RegistryValue -Key 'HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon' -Value 'JoinDomain' }
    #             { Test-RegistryValue -Key 'HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon' -Value 'AvoidSpnSet' }
    #             {
    #                 # Added test to check first if keys exists, if not each group will return $Null
    #                 # May need to evaluate what it means if one or both of these keys do not exist
    #                 ( 'HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName' | Where-Object { test-path $_ } | %{ (Get-ItemProperty -Path $_ ).ComputerName } ) -ne 
    #                 ( 'HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName' | Where-Object { Test-Path $_ } | %{ (Get-ItemProperty -Path $_ ).ComputerName } )
    #             }
    #             {
    #                 # Added test to check first if key exists
    #                 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Services\Pending' | Where-Object { 
    #                     (Test-Path $_) -and (Get-ChildItem -Path $_) } | ForEach-Object { $true }
    #             }
    #         )

    #         foreach ($test in $tests) {
    #             Write-Verbose "Running scriptblock: [$($test.ToString())]"
    #             if (& $test) {
    #                 $true
    #                 break
    #             }
    #         }
    #     }

    #     try {
    #         $output = @{
    #             IsPendingReboot = $false
    #         }

    #         if (-not ($output.IsPendingReboot = Invoke-Command -ScriptBlock $scriptBlock)) {
    #             $output.IsPendingReboot = $false
    #         }
    #         [pscustomobject]$output
    #     } catch {
    #         Write-Error -Message $_.Exception.Message
    #     }
    #   displayName: '1a: Needs a reboot?'

    # - pwsh: |
    #     Try {
    #         $PendingReboot = $false

    #         $HKLM = [UInt32] "0x80000002"
    #         $WMI_Reg = [WMIClass] "\\.\root\default:StdRegProv"

    #         if ($WMI_Reg) {
    #             if (($WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")).sNames -contains 'RebootPending') {$PendingReboot = $true}
    #             if (($WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")).sNames -contains 'RebootRequired') {$PendingReboot = $true}
    #             if (([WmiClass]"\\.\ROOT\CCM\ClientSDK:CCM_ClientUtilities").DetermineIfRebootPending().RebootPending -eq $true) {$PendingReboot = $true}

    #             if ($PendingReboot -eq $true) {
    #                 [PSCustomObject]@{
    #                     PendingReboot  = $true
    #                 }
    #                 } else {
    #                 [PSCustomObject]@{
    #                     PendingReboot  = $false
    #                 }
    #             }
    #         }
    #     } catch {
    #         Write-Error $_.Exception.Message

    #     } finally {
    #         #Clearing Variables
    #         $WMI_Reg        = $null
    #     }
    #   displayName: '1b: Needs a reboot?'

    - pwsh: |
        Remove-Item –path C:\ProgramData\iotedge\hsm\cert_keys\* –recurse -ErrorAction SilentlyContinue
        Remove-Item –path C:\ProgramData\iotedge\hsm\certs\* –recurse -ErrorAction SilentlyContinue
      displayName: Clean up HSM previous run artifacts

    - template: templates/e2e-setup.yaml

    - pwsh: |
        $certBytes = [system.Text.Encoding]::UTF8.GetBytes($env:PACKAGE_SIGNING_CERT)
        $cert = [System.Security.Cryptography.X509Certificates.X509Certificate]::new($certBytes)
        $store = New-Object System.Security.Cryptography.X509Certificates.X509Store `
          -ArgumentList 'Root', 'LocalMachine'
        $store.Open('ReadWrite')
        $store.Add($cert)
      displayName: Install CAB signing root cert
      env:
        PACKAGE_SIGNING_CERT: $(TestIotedgedPackageRootSigningCert)

    - pwsh: |
        Write-Output '>>> BEFORE:'
        netsh interface ipv6 show prefixpolicies
        netsh interface ipv6 set prefixpolicy ::ffff:0:0/96 45 4
        Write-Output '>>> AFTER:'
        netsh interface ipv6 show prefixpolicies
      displayName: Prefer IPv4

    - template: templates/e2e-clear-docker-cached-images.yaml

    # - pwsh: |
    #     $ErrorActionPreference = 'Stop'

    #     $scriptBlock = {

    #         function Test-RegistryKey {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (Get-Item -Path $Key -ErrorAction Ignore) {
    #                 $true
    #             }
    #         }

    #         function Test-RegistryValue {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key,

    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Value
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore) {
    #                 $true
    #             }
    #         }

    #         function Test-RegistryValueNotNull {
    #             [OutputType('bool')]
    #             [CmdletBinding()]
    #             param
    #             (
    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Key,

    #                 [Parameter(Mandatory)]
    #                 [ValidateNotNullOrEmpty()]
    #                 [string]$Value
    #             )
            
    #             $ErrorActionPreference = 'Stop'

    #             if (($regVal = Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore) -and $regVal.($Value)) {
    #                 $true
    #             }
    #         }

    #         # Added "test-path" to each test that did not leverage a custom function from above since
    #         # an exception is thrown when Get-ItemProperty or Get-ChildItem are passed a nonexistant key path
    #         $tests = @(
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending' }
    #             { Test-RegistryKey -Key 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootInProgress' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired' }
    #             { Test-RegistryKey -Key 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\PackagesPending' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\PostRebootReporting' }
    #             { Test-RegistryValueNotNull -Key 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager' -Value 'PendingFileRenameOperations' }
    #             { Test-RegistryValueNotNull -Key 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager' -Value 'PendingFileRenameOperations2' }
    #             { 
    #                 # Added test to check first if key exists, using "ErrorAction ignore" will incorrectly return $true
    #                 'HKLM:\SOFTWARE\Microsoft\Updates' | Where-Object { test-path $_ -PathType Container } | ForEach-Object {            
    #                     (Get-ItemProperty -Path $_ -Name 'UpdateExeVolatile' -ErrorAction Ignore | Select-Object -ExpandProperty UpdateExeVolatile) -ne 0 
    #                 }
    #             }
    #             { Test-RegistryValue -Key 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce' -Value 'DVDRebootSignal' }
    #             { Test-RegistryKey -Key 'HKLM:\SOFTWARE\Microsoft\ServerManager\CurrentRebootAttemps' }
    #             { Test-RegistryValue -Key 'HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon' -Value 'JoinDomain' }
    #             { Test-RegistryValue -Key 'HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon' -Value 'AvoidSpnSet' }
    #             {
    #                 # Added test to check first if keys exists, if not each group will return $Null
    #                 # May need to evaluate what it means if one or both of these keys do not exist
    #                 ( 'HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName' | Where-Object { test-path $_ } | %{ (Get-ItemProperty -Path $_ ).ComputerName } ) -ne 
    #                 ( 'HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName' | Where-Object { Test-Path $_ } | %{ (Get-ItemProperty -Path $_ ).ComputerName } )
    #             }
    #             {
    #                 # Added test to check first if key exists
    #                 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Services\Pending' | Where-Object { 
    #                     (Test-Path $_) -and (Get-ChildItem -Path $_) } | ForEach-Object { $true }
    #             }
    #         )

    #         foreach ($test in $tests) {
    #             Write-Verbose "Running scriptblock: [$($test.ToString())]"
    #             if (& $test) {
    #                 $true
    #                 break
    #             }
    #         }
    #     }

    #     try {
    #         $output = @{
    #             IsPendingReboot = $false
    #         }

    #         if (-not ($output.IsPendingReboot = Invoke-Command -ScriptBlock $scriptBlock)) {
    #             $output.IsPendingReboot = $false
    #         }
    #         [pscustomobject]$output
    #     } catch {
    #         Write-Error -Message $_.Exception.Message
    #     }
    #   displayName: '2a: Needs a reboot?'

    # - pwsh: |
    #     Try {
    #         $PendingReboot = $false

    #         $HKLM = [UInt32] "0x80000002"
    #         $WMI_Reg = [WMIClass] "\\.\root\default:StdRegProv"

    #         if ($WMI_Reg) {
    #             if (($WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\")).sNames -contains 'RebootPending') {$PendingReboot = $true}
    #             if (($WMI_Reg.EnumKey($HKLM,"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\")).sNames -contains 'RebootRequired') {$PendingReboot = $true}
    #             if (([WmiClass]"\\.\ROOT\CCM\ClientSDK:CCM_ClientUtilities").DetermineIfRebootPending().RebootPending -eq $true) {$PendingReboot = $true}

    #             if ($PendingReboot -eq $true) {
    #                 [PSCustomObject]@{
    #                     PendingReboot  = $true
    #                 }
    #                 } else {
    #                 [PSCustomObject]@{
    #                     PendingReboot  = $false
    #                 }
    #             }
    #         }
    #     } catch {
    #         Write-Error $_.Exception.Message

    #     } finally {
    #         #Clearing Variables
    #         $WMI_Reg        = $null
    #     }
    #   displayName: '2b: Needs a reboot?'

    - template: templates/e2e-run.yaml

# ################################################################################
#   - job: centos7_amd64
# ################################################################################
#     displayName: CentOs7 amd64

#     pool:
#       name: $(pool.name)
#       demands:
#         - Agent.OS -equals Linux
#         - Agent.OSArchitecture -equals X64
#         - run-new-e2e-tests -equals true
#         - centos -equals 7

#     variables:
#       os: linux
#       arch: amd64
#       artifactName: iotedged-centos7-amd64

#     steps:
#     - template: templates/e2e-clean-directory.yaml
#     - template: templates/e2e-setup.yaml
#     - template: templates/e2e-clear-docker-cached-images.yaml
#     - template: templates/e2e-run.yaml 

# ################################################################################
#   - job: EFLOW_amd64
# ################################################################################
#     displayName: EFLOW amd64

#     pool:
#       name: $(pool.name)
#       demands:
#         - Agent.OS -equals Linux
#         - Agent.OSArchitecture -equals X64
#         - run-new-e2e-tests -equals true
#         - eflow -equals true

#     variables:
#       os: linux
#       arch: amd64
#       artifactName: iotedged-mariner-amd64
#       NUGET_HTTP_CACHE_PATH: /var/tmp/NuGet/v3-cache
#       NUGET_PACKAGES: /var/tmp/NuGet/packages
#       NUGET_PLUGINS_CACHE_PATH: /var/tmp/NuGet/plugins-cache

#     steps:
#     - template: templates/e2e-clean-directory.yaml
#     - template: templates/e2e-setup.yaml
#     - template: templates/e2e-clear-docker-cached-images.yaml
#     - template: templates/e2e-run.yaml
